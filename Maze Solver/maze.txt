import tkinter as tk
from tkinter import ttk
import random
from collections import deque

class PathfindingVisualizer:
    def __init__(self, root):
        self.root = root
        self.root.title("AI Pathfinding Visualizer (BFS/DFS)")
        
        # UI Setup
        self.setup_controls()
        self.setup_canvas()
        
        # Maze parameters
        self.rows = 10
        self.cols = 10
        self.maze = []
        self.start = (0, 0)
        self.goal = (9, 9)
        
        # Generate initial maze
        self.generate_maze()
    
    def setup_controls(self):
        control_frame = tk.Frame(self.root)
        control_frame.pack(pady=10)
        
        self.btn_maze = ttk.Button(control_frame, text="Generate Maze", command=self.generate_maze)
        self.btn_maze.pack(side=tk.LEFT, padx=5)
        
        self.btn_bfs = ttk.Button(control_frame, text="Run BFS", command=self.run_bfs)
        self.btn_bfs.pack(side=tk.LEFT, padx=5)
        
        self.btn_dfs = ttk.Button(control_frame, text="Run DFS", command=self.run_dfs)
        self.btn_dfs.pack(side=tk.LEFT, padx=5)
        
        self.lbl_status = ttk.Label(control_frame, text="Ready")
        self.lbl_status.pack(side=tk.LEFT, padx=10)
    
    def setup_canvas(self):
        self.canvas = tk.Canvas(self.root, width=500, height=500, bg='white')
        self.canvas.pack()
        
        # Bind click events for start/goal selection
        self.canvas.bind("<Button-1>", self.set_start)
        self.canvas.bind("<Button-3>", self.set_goal)
    
    def generate_maze(self):
        """Generate a random maze with 30% walls"""
        self.maze = []
        for _ in range(self.rows):
            row = [0 if random.random() > 0.3 else 1 for _ in range(self.cols)]
            self.maze.append(row)
        
        # Ensure start and goal are walkable
        self.maze[self.start[0]][self.start[1]] = 0
        self.maze[self.goal[0]][self.goal[1]] = 0
        
        self.draw_maze()
        self.lbl_status.config(text="New maze generated")
    
    def draw_maze(self):
        """Draw the maze on canvas"""
        self.canvas.delete("all")
        cell_size = 500 // max(self.rows, self.cols)
        
        for r in range(self.rows):
            for c in range(self.cols):
                x1, y1 = c * cell_size, r * cell_size
                x2, y2 = x1 + cell_size, y1 + cell_size
                
                if self.maze[r][c] == 1:  # Wall
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill='black')
                else:  # Path
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill='white')
                
                # Draw start and goal
                if (r, c) == self.start:
                    self.canvas.create_oval(x1+5, y1+5, x2-5, y2-5, fill='green')
                elif (r, c) == self.goal:
                    self.canvas.create_oval(x1+5, y1+5, x2-5, y2-5, fill='red')
    
    def set_start(self, event):
        """Set start position on left click"""
        cell_size = 500 // max(self.rows, self.cols)
        c = event.x // cell_size
        r = event.y // cell_size
        
        if 0 <= r < self.rows and 0 <= c < self.cols and self.maze[r][c] == 0:
            self.start = (r, c)
            self.draw_maze()
            self.lbl_status.config(text=f"Start set to ({r}, {c})")
    
    def set_goal(self, event):
        """Set goal position on right click"""
        cell_size = 500 // max(self.rows, self.cols)
        c = event.x // cell_size
        r = event.y // cell_size
        
        if 0 <= r < self.rows and 0 <= c < self.cols and self.maze[r][c] == 0:
            self.goal = (r, c)
            self.draw_maze()
            self.lbl_status.config(text=f"Goal set to ({r}, {c})")
    
    def run_bfs(self):
        """Run BFS algorithm"""
        path = self.bfs()
        self.visualize_path(path, "blue")
        self.lbl_status.config(text=f"BFS found path with {len(path)-1} steps" if path else "BFS: No path found")
    
    def run_dfs(self):
        """Run DFS algorithm"""
        path = self.dfs()
        self.visualize_path(path, "purple")
        self.lbl_status.config(text=f"DFS found path with {len(path)-1} steps" if path else "DFS: No path found")
    
    def bfs(self):
        """Breadth-First Search implementation"""
        queue = deque([(self.start, [self.start])])
        visited = set()
        
        while queue:
            (r, c), path = queue.popleft()
            
            if (r, c) == self.goal:
                return path
            
            if (r, c) not in visited:
                visited.add((r, c))
                
                # Check all 4 directions
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if (0 <= nr < self.rows and 0 <= nc < self.cols and 
                        self.maze[nr][nc] == 0 and (nr, nc) not in visited):
                        queue.append(((nr, nc), path + [(nr, nc)]))
        return None
    
    def dfs(self):
        """Depth-First Search implementation"""
        stack = [(self.start, [self.start])]
        visited = set()
        
        while stack:
            (r, c), path = stack.pop()
            
            if (r, c) == self.goal:
                return path
            
            if (r, c) not in visited:
                visited.add((r, c))
                
                # Check all 4 directions (reversed order for DFS)
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if (0 <= nr < self.rows and 0 <= nc < self.cols and 
                        self.maze[nr][nc] == 0 and (nr, nc) not in visited):
                        stack.append(((nr, nc), path + [(nr, nc)]))
        return None
    
    def visualize_path(self, path, color):
        """Draw the found path on canvas"""
        self.draw_maze()
        if not path:
            return
            
        cell_size = 500 // max(self.rows, self.cols)
        
        for i in range(len(path)-1):
            r1, c1 = path[i]
            r2, c2 = path[i+1]
            
            x1 = c1 * cell_size + cell_size // 2
            y1 = r1 * cell_size + cell_size // 2
            x2 = c2 * cell_size + cell_size // 2
            y2 = r2 * cell_size + cell_size // 2
            
            self.canvas.create_line(x1, y1, x2, y2, fill=color, width=3)
        
        # Redraw start/goal over path
        r, c = self.start
        x1, y1 = c * cell_size, r * cell_size
        x2, y2 = x1 + cell_size, y1 + cell_size
        self.canvas.create_oval(x1+5, y1+5, x2-5, y2-5, fill='green')
        
        r, c = self.goal
        x1, y1 = c * cell_size, r * cell_size
        x2, y2 = x1 + cell_size, y1 + cell_size
        self.canvas.create_oval(x1+5, y1+5, x2-5, y2-5, fill='red')

if __name__ == "__main__":
    root = tk.Tk()
    app = PathfindingVisualizer(root)
    root.mainloop()